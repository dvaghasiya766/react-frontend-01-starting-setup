{"ast":null,"code":"/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport DataTile, { asImageLike } from '../../DataTile.js';\nimport ImageTile from '../../ImageTile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport { ascending } from '../../array.js';\nimport { containsCoordinate, createEmpty, equals, getIntersection, getRotatedViewport, getTopLeft, intersects } from '../../extent.js';\nimport { fromUserExtent } from '../../proj.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport { toSize } from '../../size.js';\nimport LRUCache from '../../structs/LRUCache.js';\nimport { createOrUpdate as createTileCoord, getKeyZXY } from '../../tilecoord.js';\nimport { apply as applyTransform, compose as composeTransform } from '../../transform.js';\nimport { getUid } from '../../util.js';\nimport CanvasLayerRenderer from './Layer.js';\n\n/**\n * @param {import(\"../../source/Tile.js\").default} source The tile source.\n * @param {string} sourceKey The source key.\n * @param {number} z The tile z level.\n * @param {number} x The tile x level.\n * @param {number} y The tile y level.\n * @return {string} The cache key.\n */\nfunction getCacheKey(source, sourceKey, z, x, y) {\n  return `${getUid(source)},${sourceKey},${getKeyZXY(z, x, y)}`;\n}\n\n/**\n * @typedef {Object<number, Set<import(\"../../Tile.js\").default>>} TileLookup\n */\n\n/**\n * Add a tile to the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was added to the lookup.\n */\nfunction addTileToLookup(tilesByZ, tile, z) {\n  if (!(z in tilesByZ)) {\n    tilesByZ[z] = new Set([tile]);\n    return true;\n  }\n  const set = tilesByZ[z];\n  const existing = set.has(tile);\n  if (!existing) {\n    set.add(tile);\n  }\n  return !existing;\n}\n\n/**\n * Remove a tile from the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was removed from the lookup.\n */\nfunction removeTileFromLookup(tilesByZ, tile, z) {\n  const set = tilesByZ[z];\n  if (set) {\n    return set.delete(tile);\n  }\n  return false;\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(extent, fromUserExtent(layerState.extent, frameState.viewState.projection));\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */\n  layerState.layer.getRenderSource();\n  if (!source.getWrapX()) {\n    const gridExtent = source.getTileGridForProjection(frameState.viewState.projection).getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\n/**\n * @typedef {Object} Options\n * @property {number} [cacheSize=512] The cache size.\n */\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer);\n    options = options || {};\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default|null}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedSourceKey_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedSourceRevision_;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tempExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../Tile.js\").default>}\n     * @private\n     */\n    this.tileCache_ = new LRUCache(cacheSize);\n    this.maxStaleKeys = cacheSize * 0.5;\n  }\n\n  /**\n   * @return {LRUCache} Tile cache.\n   */\n  getTileCache() {\n    return this.tileCache_;\n  }\n\n  /**\n   * Get a tile from the cache or create one if needed.\n   *\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getOrCreateTile(z, x, y, frameState) {\n    const tileCache = this.tileCache_;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const cacheKey = getCacheKey(tileSource, tileSource.getKey(), z, x, y);\n\n    /** @type {import(\"../../Tile.js\").default} */\n    let tile;\n    if (tileCache.containsKey(cacheKey)) {\n      tile = tileCache.get(cacheKey);\n    } else {\n      tile = tileSource.getTile(z, x, y, frameState.pixelRatio, frameState.viewState.projection);\n      if (!tile) {\n        return null;\n      }\n      tileCache.set(cacheKey, tile);\n    }\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getTile(z, x, y, frameState) {\n    const tile = this.getOrCreateTile(z, x, y, frameState);\n    if (!tile) {\n      return null;\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   * @override\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n    const layer = this.getLayer();\n    const coordinate = applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n    for (let z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      /**\n       * @type {import('../../DataTile.js').ImageLike}\n       */\n      let image;\n      if (tile instanceof ImageTile || tile instanceof ReprojTile) {\n        image = tile.getImage();\n      } else if (tile instanceof DataTile) {\n        image = asImageLike(tile.getData());\n        if (!image) {\n          continue;\n        }\n      } else {\n        continue;\n      }\n      const col = Math.floor(tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0]));\n      const row = Math.floor(tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1]));\n      const gutter = Math.round(tilePixelRatio * source.getGutterForProjection(viewState.projection));\n      return this.getImageData(image, col + gutter, row + gutter);\n    }\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    if (!this.renderedProjection) {\n      this.renderedProjection = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.renderedProjection) {\n      this.tileCache_.clear();\n      this.renderedProjection = frameState.viewState.projection;\n    }\n    const source = this.getLayer().getSource();\n    if (!source) {\n      return false;\n    }\n    const sourceRevision = source.getRevision();\n    if (!this.renderedSourceRevision_) {\n      this.renderedSourceRevision_ = sourceRevision;\n    } else if (this.renderedSourceRevision_ !== sourceRevision) {\n      this.renderedSourceRevision_ = sourceRevision;\n      if (this.renderedSourceKey_ === source.getKey()) {\n        this.tileCache_.clear();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(initialZ - preload, tileGrid.getMinZoom(), tileGrid.getZForResolution(Math.min(tileLayer.getMaxResolution(), map ? map.getView().getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0)) : tileGrid.getResolution(0)), tileSource.zDirection));\n    const rotation = viewState.rotation;\n    const viewport = rotation ? getRotatedViewport(viewState.center, viewState.resolution, rotation, frameState.size) : undefined;\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, this.tempTileRange_);\n      const tileResolution = tileGrid.getResolution(z);\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {\n            continue;\n          }\n          const tile = this.getTile(z, x, y, frameState);\n          if (!tile) {\n            continue;\n          }\n          const added = addTileToLookup(tilesByZ, tile, z);\n          if (!added) {\n            continue;\n          }\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n              frameState.tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tileCoord), tileResolution]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findStaleTile_(tileCoord, tilesByZ) {\n    const tileCache = this.tileCache_;\n    const z = tileCoord[0];\n    const x = tileCoord[1];\n    const y = tileCoord[2];\n    const staleKeys = this.getStaleKeys();\n    for (let i = 0; i < staleKeys.length; ++i) {\n      const cacheKey = getCacheKey(this.getLayer().getSource(), staleKeys[i], z, x, y);\n      if (tileCache.containsKey(cacheKey)) {\n        const tile = tileCache.peek(cacheKey);\n        if (tile.getState() === TileState.LOADED) {\n          tile.endTransition(getUid(this));\n          addTileToLookup(tilesByZ, tile, z);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(tileCoord, altZ, this.tempTileRange_);\n    if (!tileRange) {\n      return false;\n    }\n    let covered = true;\n    const tileCache = this.tileCache_;\n    const source = this.getLayer().getRenderSource();\n    const sourceKey = source.getKey();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(source, sourceKey, altZ, x, y);\n        let loaded = false;\n        if (tileCache.containsKey(cacheKey)) {\n          const tile = tileCache.peek(cacheKey);\n          if (tile.getState() === TileState.LOADED) {\n            addTileToLookup(tilesByZ, tile, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * Render the layer.\n   *\n   * The frame rendering logic has three parts:\n   *\n   *  1. Enqueue tiles\n   *  2. Find alt tiles for those that are not yet loaded\n   *  3. Render loaded tiles\n   *\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    this.renderComplete = true;\n\n    /**\n     * TODO:\n     *  maybe skip transition when not fully opaque\n     *  decide if this.renderComplete is useful\n     */\n\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const pixelRatio = frameState.pixelRatio;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n    const sourceKey = tileSource.getKey();\n    if (!this.renderedSourceKey_) {\n      this.renderedSourceKey_ = sourceKey;\n    } else if (this.renderedSourceKey_ !== sourceKey) {\n      this.prependStaleKey(this.renderedSourceKey_);\n      this.renderedSourceKey_ = sourceKey;\n    }\n    let frameExtent = frameState.extent;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n    const layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      frameExtent = getIntersection(frameExtent, fromUserExtent(layerState.extent, projection));\n    }\n    const dx = tileResolution * width / 2 / tilePixelRatio;\n    const dy = tileResolution * height / 2 / tilePixelRatio;\n    const canvasExtent = [viewCenter[0] - dx, viewCenter[1] - dy, viewCenter[0] + dx, viewCenter[1] + dy];\n\n    /**\n     * @type {TileLookup}\n     */\n    const tilesByZ = {};\n    this.renderedTiles.length = 0;\n\n    /**\n     * Part 1: Enqueue tiles\n     */\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(viewState.nextResolution, tileSource.zDirection);\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);\n    }\n    const renderExtent = getRenderExtent(frameState, frameExtent);\n    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(frameState, renderExtent, z - 1, tilesByZ, preload - 1);\n      }, 0);\n    }\n    if (!(z in tilesByZ)) {\n      return this.container;\n    }\n\n    /**\n     * Part 2: Find alt tiles for those that are not yet loaded\n     */\n\n    const uid = getUid(this);\n    const time = frameState.time;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tile of tilesByZ[z]) {\n      const tileState = tile.getState();\n      if (tileState === TileState.EMPTY) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n      if (tileState === TileState.LOADED) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n      }\n      if (tileState !== TileState.ERROR) {\n        this.renderComplete = false;\n      }\n      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);\n      if (hasStaleTile) {\n        // use the stale tile before the new tile's transition has completed\n        removeTileFromLookup(tilesByZ, tile, z);\n        frameState.animate = true;\n        continue;\n      }\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(tileGrid, tileCoord, z + 1, tilesByZ);\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(tileGrid, tileCoord, parentZ, tilesByZ);\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * Part 3: Render loaded tiles\n     */\n\n    const canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio;\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);\n    if (layerState.extent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n    this.preRender(context, frameState);\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(tilesByZ).map(Number);\n    zs.sort(ascending);\n    let currentClip;\n    const clips = [];\n    const clipZs = [];\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution, tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution]);\n      const tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n      for (const tile of tilesByZ[currentZ]) {\n        if (tile.getState() !== TileState.LOADED) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = zs.length === 1;\n        let contextSaved = false;\n\n        // Clip mask for regions in this tile that already filled by a higher z tile\n        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n        for (let i = 0, ii = clips.length; i < ii; ++i) {\n          if (!transition && currentZ < clipZs[i]) {\n            const clip = clips[i];\n            if (intersects([x, y, x + w, y + h], [clip[0], clip[3], clip[4], clip[7]])) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);\n        if (contextSaved) {\n          context.restore();\n        }\n        this.renderedTiles.unshift(tile);\n\n        // TODO: decide if this is necessary\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n    this.renderedResolution = tileResolution;\n    this.extentChanged = !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.postRender(this.context, frameState);\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n    if (this.renderComplete) {\n      /**\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = (map, frameState) => {\n        const tileSourceKey = getUid(tileSource);\n        const wantedTiles = frameState.wantedTiles[tileSourceKey];\n        const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;\n        this.updateCacheSize(tilesCount);\n        this.tileCache_.expireCache();\n      };\n      frameState.postRenderFunctions.push(postRenderFunction);\n    }\n    return this.container;\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   */\n  updateCacheSize(tileCount) {\n    this.tileCache_.highWaterMark = Math.max(this.tileCache_.highWaterMark, tileCount * 2);\n  }\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @protected\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    let image;\n    if (tile instanceof DataTile) {\n      image = asImageLike(tile.getData());\n      if (!image) {\n        throw new Error('Rendering array data is not yet supported');\n      }\n    } else {\n      image = this.getTileImage(/** @type {import(\"../../ImageTile.js\").default} */tile);\n    }\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha = layerState.opacity * (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n}\nexport default CanvasTileLayerRenderer;","map":{"version":3,"names":["DataTile","asImageLike","ImageTile","TileRange","TileState","ascending","containsCoordinate","createEmpty","equals","getIntersection","getRotatedViewport","getTopLeft","intersects","fromUserExtent","ReprojTile","toSize","LRUCache","createOrUpdate","createTileCoord","getKeyZXY","apply","applyTransform","compose","composeTransform","getUid","CanvasLayerRenderer","getCacheKey","source","sourceKey","z","x","y","addTileToLookup","tilesByZ","tile","Set","set","existing","has","add","removeTileFromLookup","delete","getRenderExtent","frameState","extent","layerState","layerStatesArray","layerIndex","viewState","projection","layer","getRenderSource","getWrapX","gridExtent","getTileGridForProjection","getExtent","CanvasTileLayerRenderer","constructor","tileLayer","options","extentChanged","renderComplete","renderedExtent_","renderedPixelRatio","renderedProjection","renderedTiles","renderedSourceKey_","renderedSourceRevision_","tempExtent","tempTileRange_","tempTileCoord_","cacheSize","undefined","tileCache_","maxStaleKeys","getTileCache","getOrCreateTile","tileCache","getLayer","tileSource","getSource","cacheKey","getKey","containsKey","get","getTile","pixelRatio","getData","pixel","coordinate","pixelToCoordinateTransform","slice","layerExtent","tileGrid","tilePixelRatio","getTilePixelRatio","getZForResolution","resolution","getMinZoom","tileCoord","getTileCoordForCoordAndZ","getState","LOADED","tileOrigin","getOrigin","tileSize","getTileSize","tileResolution","getResolution","image","getImage","col","Math","floor","row","gutter","round","getGutterForProjection","getImageData","prepareFrame","clear","sourceRevision","getRevision","enqueueTiles","initialZ","preload","tileSourceKey","wantedTiles","map","getMapInternal","minZ","max","min","getMaxResolution","getView","getResolutionForZoom","zDirection","rotation","viewport","center","size","tileRange","getTileRangeForExtentAndZ","minX","maxX","minY","maxY","tileCoordIntersectsViewport","added","tileQueueKey","IDLE","tileQueue","isKeyQueued","enqueue","getTileCoordCenter","findStaleTile_","staleKeys","getStaleKeys","i","length","peek","endTransition","findAltTiles_","altZ","getTileRangeForTileCoordAndZ","covered","loaded","renderFrame","target","viewResolution","viewCenter","prependStaleKey","frameExtent","prepareContainer","width","context","canvas","height","dx","dy","canvasExtent","getPreload","nextExtent","targetZ","nextResolution","renderExtent","setTimeout","container","uid","time","tileState","EMPTY","alpha","getAlpha","ERROR","hasStaleTile","animate","coveredByChildren","minZoom","parentZ","coveredByParent","canvasScale","getRenderContext","tempTransform","clipUnrotated","getInterpolate","imageSmoothingEnabled","preRender","zs","Object","keys","Number","sort","currentClip","clips","clipZs","currentZ","currentTilePixelSize","getTilePixelSize","currentResolution","currentScale","originTileCoord","originTileExtent","getTileCoordExtent","origin","tileGutter","xIndex","nextX","yIndex","nextY","w","h","transition","contextSaved","ii","clip","save","beginPath","moveTo","lineTo","push","drawTile","restore","unshift","updateUsedTiles","usedTiles","renderedResolution","postRender","postRenderFunction","tilesCount","updateCacheSize","expireCache","postRenderFunctions","tileCount","highWaterMark","Error","getTileImage","opacity","alphaChanged","globalAlpha","drawImage"],"sources":["F:/Dev/Tutorial/React/Udemy/react-frontend-01-starting-setup/node_modules/ol/renderer/canvas/TileLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport DataTile, {asImageLike} from '../../DataTile.js';\nimport ImageTile from '../../ImageTile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getIntersection,\n  getRotatedViewport,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport {toSize} from '../../size.js';\nimport LRUCache from '../../structs/LRUCache.js';\nimport {createOrUpdate as createTileCoord, getKeyZXY} from '../../tilecoord.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n} from '../../transform.js';\nimport {getUid} from '../../util.js';\nimport CanvasLayerRenderer from './Layer.js';\n\n/**\n * @param {import(\"../../source/Tile.js\").default} source The tile source.\n * @param {string} sourceKey The source key.\n * @param {number} z The tile z level.\n * @param {number} x The tile x level.\n * @param {number} y The tile y level.\n * @return {string} The cache key.\n */\nfunction getCacheKey(source, sourceKey, z, x, y) {\n  return `${getUid(source)},${sourceKey},${getKeyZXY(z, x, y)}`;\n}\n\n/**\n * @typedef {Object<number, Set<import(\"../../Tile.js\").default>>} TileLookup\n */\n\n/**\n * Add a tile to the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was added to the lookup.\n */\nfunction addTileToLookup(tilesByZ, tile, z) {\n  if (!(z in tilesByZ)) {\n    tilesByZ[z] = new Set([tile]);\n    return true;\n  }\n  const set = tilesByZ[z];\n  const existing = set.has(tile);\n  if (!existing) {\n    set.add(tile);\n  }\n  return !existing;\n}\n\n/**\n * Remove a tile from the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was removed from the lookup.\n */\nfunction removeTileFromLookup(tilesByZ, tile, z) {\n  const set = tilesByZ[z];\n  if (set) {\n    return set.delete(tile);\n  }\n  return false;\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection),\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\n/**\n * @typedef {Object} Options\n * @property {number} [cacheSize=512] The cache size.\n */\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer);\n\n    options = options || {};\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default|null}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedSourceKey_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedSourceRevision_;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tempExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../Tile.js\").default>}\n     * @private\n     */\n    this.tileCache_ = new LRUCache(cacheSize);\n\n    this.maxStaleKeys = cacheSize * 0.5;\n  }\n\n  /**\n   * @return {LRUCache} Tile cache.\n   */\n  getTileCache() {\n    return this.tileCache_;\n  }\n\n  /**\n   * Get a tile from the cache or create one if needed.\n   *\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getOrCreateTile(z, x, y, frameState) {\n    const tileCache = this.tileCache_;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const cacheKey = getCacheKey(tileSource, tileSource.getKey(), z, x, y);\n\n    /** @type {import(\"../../Tile.js\").default} */\n    let tile;\n\n    if (tileCache.containsKey(cacheKey)) {\n      tile = tileCache.get(cacheKey);\n    } else {\n      tile = tileSource.getTile(\n        z,\n        x,\n        y,\n        frameState.pixelRatio,\n        frameState.viewState.projection,\n      );\n      if (!tile) {\n        return null;\n      }\n      tileCache.set(cacheKey, tile);\n    }\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getTile(z, x, y, frameState) {\n    const tile = this.getOrCreateTile(z, x, y, frameState);\n    if (!tile) {\n      return null;\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   * @override\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      /**\n       * @type {import('../../DataTile.js').ImageLike}\n       */\n      let image;\n      if (tile instanceof ImageTile || tile instanceof ReprojTile) {\n        image = tile.getImage();\n      } else if (tile instanceof DataTile) {\n        image = asImageLike(tile.getData());\n        if (!image) {\n          continue;\n        }\n      } else {\n        continue;\n      }\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0]),\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1]),\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection),\n      );\n\n      return this.getImageData(image, col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    if (!this.renderedProjection) {\n      this.renderedProjection = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.renderedProjection) {\n      this.tileCache_.clear();\n      this.renderedProjection = frameState.viewState.projection;\n    }\n\n    const source = this.getLayer().getSource();\n    if (!source) {\n      return false;\n    }\n    const sourceRevision = source.getRevision();\n    if (!this.renderedSourceRevision_) {\n      this.renderedSourceRevision_ = sourceRevision;\n    } else if (this.renderedSourceRevision_ !== sourceRevision) {\n      this.renderedSourceRevision_ = sourceRevision;\n      if (this.renderedSourceKey_ === source.getKey()) {\n        this.tileCache_.clear();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(\n      initialZ - preload,\n      tileGrid.getMinZoom(),\n      tileGrid.getZForResolution(\n        Math.min(\n          tileLayer.getMaxResolution(),\n          map\n            ? map\n                .getView()\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\n            : tileGrid.getResolution(0),\n        ),\n        tileSource.zDirection,\n      ),\n    );\n    const rotation = viewState.rotation;\n    const viewport = rotation\n      ? getRotatedViewport(\n          viewState.center,\n          viewState.resolution,\n          rotation,\n          frameState.size,\n        )\n      : undefined;\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_,\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (\n            rotation &&\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n          ) {\n            continue;\n          }\n          const tile = this.getTile(z, x, y, frameState);\n          if (!tile) {\n            continue;\n          }\n          const added = addTileToLookup(tilesByZ, tile, z);\n          if (!added) {\n            continue;\n          }\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findStaleTile_(tileCoord, tilesByZ) {\n    const tileCache = this.tileCache_;\n    const z = tileCoord[0];\n    const x = tileCoord[1];\n    const y = tileCoord[2];\n    const staleKeys = this.getStaleKeys();\n    for (let i = 0; i < staleKeys.length; ++i) {\n      const cacheKey = getCacheKey(\n        this.getLayer().getSource(),\n        staleKeys[i],\n        z,\n        x,\n        y,\n      );\n      if (tileCache.containsKey(cacheKey)) {\n        const tile = tileCache.peek(cacheKey);\n        if (tile.getState() === TileState.LOADED) {\n          tile.endTransition(getUid(this));\n          addTileToLookup(tilesByZ, tile, z);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_,\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileCache = this.tileCache_;\n    const source = this.getLayer().getRenderSource();\n    const sourceKey = source.getKey();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(source, sourceKey, altZ, x, y);\n        let loaded = false;\n        if (tileCache.containsKey(cacheKey)) {\n          const tile = tileCache.peek(cacheKey);\n          if (tile.getState() === TileState.LOADED) {\n            addTileToLookup(tilesByZ, tile, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * Render the layer.\n   *\n   * The frame rendering logic has three parts:\n   *\n   *  1. Enqueue tiles\n   *  2. Find alt tiles for those that are not yet loaded\n   *  3. Render loaded tiles\n   *\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    this.renderComplete = true;\n\n    /**\n     * TODO:\n     *  maybe skip transition when not fully opaque\n     *  decide if this.renderComplete is useful\n     */\n\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    const sourceKey = tileSource.getKey();\n    if (!this.renderedSourceKey_) {\n      this.renderedSourceKey_ = sourceKey;\n    } else if (this.renderedSourceKey_ !== sourceKey) {\n      this.prependStaleKey(this.renderedSourceKey_);\n      this.renderedSourceKey_ = sourceKey;\n    }\n\n    let frameExtent = frameState.extent;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      frameExtent = getIntersection(\n        frameExtent,\n        fromUserExtent(layerState.extent, projection),\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    /**\n     * @type {TileLookup}\n     */\n    const tilesByZ = {};\n\n    this.renderedTiles.length = 0;\n\n    /**\n     * Part 1: Enqueue tiles\n     */\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection,\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);\n    }\n\n    const renderExtent = getRenderExtent(frameState, frameExtent);\n    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(\n          frameState,\n          renderExtent,\n          z - 1,\n          tilesByZ,\n          preload - 1,\n        );\n      }, 0);\n    }\n\n    if (!(z in tilesByZ)) {\n      return this.container;\n    }\n\n    /**\n     * Part 2: Find alt tiles for those that are not yet loaded\n     */\n\n    const uid = getUid(this);\n    const time = frameState.time;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tile of tilesByZ[z]) {\n      const tileState = tile.getState();\n      if (tileState === TileState.EMPTY) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n\n      if (tileState === TileState.LOADED) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n      }\n      if (tileState !== TileState.ERROR) {\n        this.renderComplete = false;\n      }\n\n      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);\n      if (hasStaleTile) {\n        // use the stale tile before the new tile's transition has completed\n        removeTileFromLookup(tilesByZ, tile, z);\n        frameState.animate = true;\n        continue;\n      }\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(\n        tileGrid,\n        tileCoord,\n        z + 1,\n        tilesByZ,\n      );\n\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          parentZ,\n          tilesByZ,\n        );\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * Part 3: Render loaded tiles\n     */\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2,\n    );\n\n    if (layerState.extent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(tilesByZ).map(Number);\n    zs.sort(ascending);\n\n    let currentClip;\n    const clips = [];\n    const clipZs = [];\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection,\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ,\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      for (const tile of tilesByZ[currentZ]) {\n        if (tile.getState() !== TileState.LOADED) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = zs.length === 1;\n\n        let contextSaved = false;\n\n        // Clip mask for regions in this tile that already filled by a higher z tile\n        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n        for (let i = 0, ii = clips.length; i < ii; ++i) {\n          if (!transition && currentZ < clipZs[i]) {\n            const clip = clips[i];\n            if (\n              intersects(\n                [x, y, x + w, y + h],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n\n        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);\n        if (contextSaved) {\n          context.restore();\n        }\n        this.renderedTiles.unshift(tile);\n\n        // TODO: decide if this is necessary\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n\n    this.postRender(this.context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (this.renderComplete) {\n      /**\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = (map, frameState) => {\n        const tileSourceKey = getUid(tileSource);\n        const wantedTiles = frameState.wantedTiles[tileSourceKey];\n        const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;\n        this.updateCacheSize(tilesCount);\n        this.tileCache_.expireCache();\n      };\n\n      frameState.postRenderFunctions.push(postRenderFunction);\n    }\n\n    return this.container;\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   */\n  updateCacheSize(tileCount) {\n    this.tileCache_.highWaterMark = Math.max(\n      this.tileCache_.highWaterMark,\n      tileCount * 2,\n    );\n  }\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @protected\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    let image;\n    if (tile instanceof DataTile) {\n      image = asImageLike(tile.getData());\n      if (!image) {\n        throw new Error('Rendering array data is not yet supported');\n      }\n    } else {\n      image = this.getTileImage(\n        /** @type {import(\"../../ImageTile.js\").default} */ (tile),\n      );\n    }\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h,\n    );\n\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}