{"ast":null,"code":"/**\n * @module ol/style/RegularShape\n */\n\nimport ImageState from '../ImageState.js';\nimport { asArray } from '../color.js';\nimport { asColorLike } from '../colorlike.js';\nimport { createCanvasContext2D } from '../dom.js';\nimport { defaultFillStyle, defaultLineCap, defaultLineJoin, defaultLineWidth, defaultMiterLimit, defaultStrokeStyle } from '../render/canvas.js';\nimport IconImage from './IconImage.js';\nimport { shared as iconImageCache } from './IconImageCache.js';\nimport ImageStyle from './Image.js';\n\n/**\n * Specify radius for regular polygons, or both radius and radius2 for stars.\n * @typedef {Object} Options\n * @property {import(\"./Fill.js\").default} [fill] Fill style.\n * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points\n * is the number of sides.\n * @property {number} radius Radius of a regular polygon.\n * @property {number} [radius2] Second radius to make a star instead of a regular polygon.\n * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's points facing up.\n * @property {Array<number>} [displacement=[0, 0]] Displacement of the shape in pixels.\n * Positive values will shift the shape right and up.\n * @property {import(\"./Stroke.js\").default} [stroke] Stroke style.\n * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).\n * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.\n * @property {number|import(\"../size.js\").Size} [scale=1] Scale. Unless two dimensional scaling is required a better\n * result may be obtained with appropriate settings for `radius` and `radius2`.\n * @property {import('./Style.js').DeclutterMode} [declutterMode] Declutter mode.\n */\n\n/**\n * @typedef {Object} RenderOptions\n * @property {import(\"../colorlike.js\").ColorLike|undefined} strokeStyle StrokeStyle.\n * @property {number} strokeWidth StrokeWidth.\n * @property {number} size Size.\n * @property {CanvasLineCap} lineCap LineCap.\n * @property {Array<number>|null} lineDash LineDash.\n * @property {number} lineDashOffset LineDashOffset.\n * @property {CanvasLineJoin} lineJoin LineJoin.\n * @property {number} miterLimit MiterLimit.\n */\n\n/**\n * @classdesc\n * Set regular shape style for vector features. The resulting shape will be\n * a regular polygon when `radius` is provided, or a star when both `radius` and\n * `radius2` are provided.\n * @api\n */\nclass RegularShape extends ImageStyle {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    super({\n      opacity: 1,\n      rotateWithView: options.rotateWithView !== undefined ? options.rotateWithView : false,\n      rotation: options.rotation !== undefined ? options.rotation : 0,\n      scale: options.scale !== undefined ? options.scale : 1,\n      displacement: options.displacement !== undefined ? options.displacement : [0, 0],\n      declutterMode: options.declutterMode\n    });\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement|null}\n     */\n    this.hitDetectionCanvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Fill.js\").default|null}\n     */\n    this.fill_ = options.fill !== undefined ? options.fill : null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.origin_ = [0, 0];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.points_ = options.points;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.radius = options.radius;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.radius2_ = options.radius2;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.angle_ = options.angle !== undefined ? options.angle : 0;\n\n    /**\n     * @private\n     * @type {import(\"./Stroke.js\").default|null}\n     */\n    this.stroke_ = options.stroke !== undefined ? options.stroke : null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.size_;\n\n    /**\n     * @private\n     * @type {RenderOptions}\n     */\n    this.renderOptions_;\n\n    /**\n     * @private\n     */\n    this.imageState_ = this.fill_ && this.fill_.loading() ? ImageState.LOADING : ImageState.LOADED;\n    if (this.imageState_ === ImageState.LOADING) {\n      this.ready().then(() => this.imageState_ = ImageState.LOADED);\n    }\n    this.render();\n  }\n\n  /**\n   * Clones the style.\n   * @return {RegularShape} The cloned style.\n   * @api\n   * @override\n   */\n  clone() {\n    const scale = this.getScale();\n    const style = new RegularShape({\n      fill: this.getFill() ? this.getFill().clone() : undefined,\n      points: this.getPoints(),\n      radius: this.getRadius(),\n      radius2: this.getRadius2(),\n      angle: this.getAngle(),\n      stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n      rotation: this.getRotation(),\n      rotateWithView: this.getRotateWithView(),\n      scale: Array.isArray(scale) ? scale.slice() : scale,\n      displacement: this.getDisplacement().slice(),\n      declutterMode: this.getDeclutterMode()\n    });\n    style.setOpacity(this.getOpacity());\n    return style;\n  }\n\n  /**\n   * Get the anchor point in pixels. The anchor determines the center point for the\n   * symbolizer.\n   * @return {Array<number>} Anchor.\n   * @api\n   * @override\n   */\n  getAnchor() {\n    const size = this.size_;\n    const displacement = this.getDisplacement();\n    const scale = this.getScaleArray();\n    // anchor is scaled by renderer but displacement should not be scaled\n    // so divide by scale here\n    return [size[0] / 2 - displacement[0] / scale[0], size[1] / 2 + displacement[1] / scale[1]];\n  }\n\n  /**\n   * Get the angle used in generating the shape.\n   * @return {number} Shape's rotation in radians.\n   * @api\n   */\n  getAngle() {\n    return this.angle_;\n  }\n\n  /**\n   * Get the fill style for the shape.\n   * @return {import(\"./Fill.js\").default|null} Fill style.\n   * @api\n   */\n  getFill() {\n    return this.fill_;\n  }\n\n  /**\n   * Set the fill style.\n   * @param {import(\"./Fill.js\").default|null} fill Fill style.\n   * @api\n   */\n  setFill(fill) {\n    this.fill_ = fill;\n    this.render();\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image element.\n   * @override\n   */\n  getHitDetectionImage() {\n    if (!this.hitDetectionCanvas_) {\n      this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(this.renderOptions_);\n    }\n    return this.hitDetectionCanvas_;\n  }\n\n  /**\n   * Get the image icon.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {HTMLCanvasElement} Image or Canvas element.\n   * @api\n   * @override\n   */\n  getImage(pixelRatio) {\n    const fillKey = this.fill_?.getKey();\n    const cacheKey = `${pixelRatio},${this.angle_},${this.radius},${this.radius2_},${this.points_},${fillKey}` + Object.values(this.renderOptions_).join(',');\n    let image = /** @type {HTMLCanvasElement} */\n    iconImageCache.get(cacheKey, null, null)?.getImage(1);\n    if (!image) {\n      const renderOptions = this.renderOptions_;\n      const size = Math.ceil(renderOptions.size * pixelRatio);\n      const context = createCanvasContext2D(size, size);\n      this.draw_(renderOptions, context, pixelRatio);\n      image = context.canvas;\n      iconImageCache.set(cacheKey, null, null, new IconImage(image, undefined, null, ImageState.LOADED, null));\n    }\n    return image;\n  }\n\n  /**\n   * Get the image pixel ratio.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Pixel ratio.\n   * @override\n   */\n  getPixelRatio(pixelRatio) {\n    return pixelRatio;\n  }\n\n  /**\n   * @return {import(\"../size.js\").Size} Image size.\n   * @override\n   */\n  getImageSize() {\n    return this.size_;\n  }\n\n  /**\n   * @return {import(\"../ImageState.js\").default} Image state.\n   * @override\n   */\n  getImageState() {\n    return this.imageState_;\n  }\n\n  /**\n   * Get the origin of the symbolizer.\n   * @return {Array<number>} Origin.\n   * @api\n   * @override\n   */\n  getOrigin() {\n    return this.origin_;\n  }\n\n  /**\n   * Get the number of points for generating the shape.\n   * @return {number} Number of points for stars and regular polygons.\n   * @api\n   */\n  getPoints() {\n    return this.points_;\n  }\n\n  /**\n   * Get the (primary) radius for the shape.\n   * @return {number} Radius.\n   * @api\n   */\n  getRadius() {\n    return this.radius;\n  }\n\n  /**\n   * Get the secondary radius for the shape.\n   * @return {number|undefined} Radius2.\n   * @api\n   */\n  getRadius2() {\n    return this.radius2_;\n  }\n\n  /**\n   * Get the size of the symbolizer (in pixels).\n   * @return {import(\"../size.js\").Size} Size.\n   * @api\n   * @override\n   */\n  getSize() {\n    return this.size_;\n  }\n\n  /**\n   * Get the stroke style for the shape.\n   * @return {import(\"./Stroke.js\").default|null} Stroke style.\n   * @api\n   */\n  getStroke() {\n    return this.stroke_;\n  }\n\n  /**\n   * Set the stroke style.\n   * @param {import(\"./Stroke.js\").default|null} stroke Stroke style.\n   * @api\n   */\n  setStroke(stroke) {\n    this.stroke_ = stroke;\n    this.render();\n  }\n\n  /**\n   * @param {function(import(\"../events/Event.js\").default): void} listener Listener function.\n   * @override\n   */\n  listenImageChange(listener) {}\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {}\n\n  /**\n   * @param {function(import(\"../events/Event.js\").default): void} listener Listener function.\n   * @override\n   */\n  unlistenImageChange(listener) {}\n\n  /**\n   * Calculate additional canvas size needed for the miter.\n   * @param {string} lineJoin Line join\n   * @param {number} strokeWidth Stroke width\n   * @param {number} miterLimit Miter limit\n   * @return {number} Additional canvas size needed\n   * @private\n   */\n  calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {\n    if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== 'bevel' && lineJoin !== 'miter') {\n      return strokeWidth;\n    }\n    // m  | ^\n    // i  | |\\                  .\n    // t >|  #\\\n    // e  | |\\ \\              .\n    // r      \\s\\\n    //      |  \\t\\          .                 .\n    //          \\r\\                      .   .\n    //      |    \\o\\      .          .  . . .\n    //          e \\k\\            .  .    . .\n    //      |      \\e\\  .    .  .       . .\n    //       d      \\ \\  .  .          . .\n    //      | _ _a_ _\\#  .            . .\n    //   r1          / `             . .\n    //      |                       . .\n    //       b     /               . .\n    //      |                     . .\n    //           / r2            . .\n    //      |                        .   .\n    //         /                           .   .\n    //      |α                                   .   .\n    //       /                                         .   .\n    //      ° center\n    let r1 = this.radius;\n    let r2 = this.radius2_ === undefined ? r1 : this.radius2_;\n    if (r1 < r2) {\n      const tmp = r1;\n      r1 = r2;\n      r2 = tmp;\n    }\n    const points = this.radius2_ === undefined ? this.points_ : this.points_ * 2;\n    const alpha = 2 * Math.PI / points;\n    const a = r2 * Math.sin(alpha);\n    const b = Math.sqrt(r2 * r2 - a * a);\n    const d = r1 - b;\n    const e = Math.sqrt(a * a + d * d);\n    const miterRatio = e / a;\n    if (lineJoin === 'miter' && miterRatio <= miterLimit) {\n      return miterRatio * strokeWidth;\n    }\n    // Calculate the distance from center to the stroke corner where\n    // it was cut short because of the miter limit.\n    //              l\n    //        ----+---- <= distance from center to here is maxr\n    //       /####|k ##\\\n    //      /#####^#####\\\n    //     /#### /+\\# s #\\\n    //    /### h/+++\\# t #\\\n    //   /### t/+++++\\# r #\\\n    //  /### a/+++++++\\# o #\\\n    // /### p/++ fill +\\# k #\\\n    ///#### /+++++^+++++\\# e #\\\n    //#####/+++++/+\\+++++\\#####\\\n    const k = strokeWidth / 2 / miterRatio;\n    const l = strokeWidth / 2 * (d / e);\n    const maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);\n    const bevelAdd = maxr - r1;\n    if (this.radius2_ === undefined || lineJoin === 'bevel') {\n      return bevelAdd * 2;\n    }\n    // If outer miter is over the miter limit the inner miter may reach through the\n    // center and be longer than the bevel, same calculation as above but swap r1 / r2.\n    const aa = r1 * Math.sin(alpha);\n    const bb = Math.sqrt(r1 * r1 - aa * aa);\n    const dd = r2 - bb;\n    const ee = Math.sqrt(aa * aa + dd * dd);\n    const innerMiterRatio = ee / aa;\n    if (innerMiterRatio <= miterLimit) {\n      const innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;\n      return 2 * Math.max(bevelAdd, innerLength);\n    }\n    return bevelAdd * 2;\n  }\n\n  /**\n   * @return {RenderOptions}  The render options\n   * @protected\n   */\n  createRenderOptions() {\n    let lineCap = defaultLineCap;\n    let lineJoin = defaultLineJoin;\n    let miterLimit = 0;\n    let lineDash = null;\n    let lineDashOffset = 0;\n    let strokeStyle;\n    let strokeWidth = 0;\n    if (this.stroke_) {\n      strokeStyle = asColorLike(this.stroke_.getColor() ?? defaultStrokeStyle);\n      strokeWidth = this.stroke_.getWidth() ?? defaultLineWidth;\n      lineDash = this.stroke_.getLineDash();\n      lineDashOffset = this.stroke_.getLineDashOffset() ?? 0;\n      lineJoin = this.stroke_.getLineJoin() ?? defaultLineJoin;\n      lineCap = this.stroke_.getLineCap() ?? defaultLineCap;\n      miterLimit = this.stroke_.getMiterLimit() ?? defaultMiterLimit;\n    }\n    const add = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);\n    const maxRadius = Math.max(this.radius, this.radius2_ || 0);\n    const size = Math.ceil(2 * maxRadius + add);\n    return {\n      strokeStyle: strokeStyle,\n      strokeWidth: strokeWidth,\n      size: size,\n      lineCap: lineCap,\n      lineDash: lineDash,\n      lineDashOffset: lineDashOffset,\n      lineJoin: lineJoin,\n      miterLimit: miterLimit\n    };\n  }\n\n  /**\n   * @protected\n   */\n  render() {\n    this.renderOptions_ = this.createRenderOptions();\n    const size = this.renderOptions_.size;\n    this.hitDetectionCanvas_ = null;\n    this.size_ = [size, size];\n  }\n\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   * @param {CanvasRenderingContext2D} context The rendering context.\n   * @param {number} pixelRatio The pixel ratio.\n   */\n  draw_(renderOptions, context, pixelRatio) {\n    context.scale(pixelRatio, pixelRatio);\n    // set origin to canvas center\n    context.translate(renderOptions.size / 2, renderOptions.size / 2);\n    this.createPath_(context);\n    if (this.fill_) {\n      let color = this.fill_.getColor();\n      if (color === null) {\n        color = defaultFillStyle;\n      }\n      context.fillStyle = asColorLike(color);\n      context.fill();\n    }\n    if (renderOptions.strokeStyle) {\n      context.strokeStyle = renderOptions.strokeStyle;\n      context.lineWidth = renderOptions.strokeWidth;\n      if (renderOptions.lineDash) {\n        context.setLineDash(renderOptions.lineDash);\n        context.lineDashOffset = renderOptions.lineDashOffset;\n      }\n      context.lineCap = renderOptions.lineCap;\n      context.lineJoin = renderOptions.lineJoin;\n      context.miterLimit = renderOptions.miterLimit;\n      context.stroke();\n    }\n  }\n\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   * @return {HTMLCanvasElement} Canvas containing the icon\n   */\n  createHitDetectionCanvas_(renderOptions) {\n    let context;\n    if (this.fill_) {\n      let color = this.fill_.getColor();\n\n      // determine if fill is transparent (or pattern or gradient)\n      let opacity = 0;\n      if (typeof color === 'string') {\n        color = asArray(color);\n      }\n      if (color === null) {\n        opacity = 1;\n      } else if (Array.isArray(color)) {\n        opacity = color.length === 4 ? color[3] : 1;\n      }\n      if (opacity === 0) {\n        // if a transparent fill style is set, create an extra hit-detection image\n        // with a default fill style\n        context = createCanvasContext2D(renderOptions.size, renderOptions.size);\n        this.drawHitDetectionCanvas_(renderOptions, context);\n      }\n    }\n    return context ? context.canvas : this.getImage(1);\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context The context to draw in.\n   */\n  createPath_(context) {\n    let points = this.points_;\n    const radius = this.radius;\n    if (points === Infinity) {\n      context.arc(0, 0, radius, 0, 2 * Math.PI);\n    } else {\n      const radius2 = this.radius2_ === undefined ? radius : this.radius2_;\n      if (this.radius2_ !== undefined) {\n        points *= 2;\n      }\n      const startAngle = this.angle_ - Math.PI / 2;\n      const step = 2 * Math.PI / points;\n      for (let i = 0; i < points; i++) {\n        const angle0 = startAngle + i * step;\n        const radiusC = i % 2 === 0 ? radius : radius2;\n        context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));\n      }\n      context.closePath();\n    }\n  }\n\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   * @param {CanvasRenderingContext2D} context The context.\n   */\n  drawHitDetectionCanvas_(renderOptions, context) {\n    // set origin to canvas center\n    context.translate(renderOptions.size / 2, renderOptions.size / 2);\n    this.createPath_(context);\n    context.fillStyle = defaultFillStyle;\n    context.fill();\n    if (renderOptions.strokeStyle) {\n      context.strokeStyle = renderOptions.strokeStyle;\n      context.lineWidth = renderOptions.strokeWidth;\n      if (renderOptions.lineDash) {\n        context.setLineDash(renderOptions.lineDash);\n        context.lineDashOffset = renderOptions.lineDashOffset;\n      }\n      context.lineJoin = renderOptions.lineJoin;\n      context.miterLimit = renderOptions.miterLimit;\n      context.stroke();\n    }\n  }\n\n  /**\n   * @override\n   */\n  ready() {\n    return this.fill_ ? this.fill_.ready() : Promise.resolve();\n  }\n}\nexport default RegularShape;","map":{"version":3,"names":["ImageState","asArray","asColorLike","createCanvasContext2D","defaultFillStyle","defaultLineCap","defaultLineJoin","defaultLineWidth","defaultMiterLimit","defaultStrokeStyle","IconImage","shared","iconImageCache","ImageStyle","RegularShape","constructor","options","opacity","rotateWithView","undefined","rotation","scale","displacement","declutterMode","hitDetectionCanvas_","fill_","fill","origin_","points_","points","radius","radius2_","radius2","angle_","angle","stroke_","stroke","size_","renderOptions_","imageState_","loading","LOADING","LOADED","ready","then","render","clone","getScale","style","getFill","getPoints","getRadius","getRadius2","getAngle","getStroke","getRotation","getRotateWithView","Array","isArray","slice","getDisplacement","getDeclutterMode","setOpacity","getOpacity","getAnchor","size","getScaleArray","setFill","getHitDetectionImage","createHitDetectionCanvas_","getImage","pixelRatio","fillKey","getKey","cacheKey","Object","values","join","image","get","renderOptions","Math","ceil","context","draw_","canvas","set","getPixelRatio","getImageSize","getImageState","getOrigin","getSize","setStroke","listenImageChange","listener","load","unlistenImageChange","calculateLineJoinSize_","lineJoin","strokeWidth","miterLimit","Infinity","r1","r2","tmp","alpha","PI","a","sin","b","sqrt","d","e","miterRatio","k","l","maxr","bevelAdd","aa","bb","dd","ee","innerMiterRatio","innerLength","max","createRenderOptions","lineCap","lineDash","lineDashOffset","strokeStyle","getColor","getWidth","getLineDash","getLineDashOffset","getLineJoin","getLineCap","getMiterLimit","add","maxRadius","translate","createPath_","color","fillStyle","lineWidth","setLineDash","length","drawHitDetectionCanvas_","arc","startAngle","step","i","angle0","radiusC","lineTo","cos","closePath","Promise","resolve"],"sources":["F:/Dev/Tutorial/React/Udemy/react-frontend-01-starting-setup/node_modules/ol/style/RegularShape.js"],"sourcesContent":["/**\n * @module ol/style/RegularShape\n */\n\nimport ImageState from '../ImageState.js';\nimport {asArray} from '../color.js';\nimport {asColorLike} from '../colorlike.js';\nimport {createCanvasContext2D} from '../dom.js';\nimport {\n  defaultFillStyle,\n  defaultLineCap,\n  defaultLineJoin,\n  defaultLineWidth,\n  defaultMiterLimit,\n  defaultStrokeStyle,\n} from '../render/canvas.js';\nimport IconImage from './IconImage.js';\nimport {shared as iconImageCache} from './IconImageCache.js';\nimport ImageStyle from './Image.js';\n\n/**\n * Specify radius for regular polygons, or both radius and radius2 for stars.\n * @typedef {Object} Options\n * @property {import(\"./Fill.js\").default} [fill] Fill style.\n * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points\n * is the number of sides.\n * @property {number} radius Radius of a regular polygon.\n * @property {number} [radius2] Second radius to make a star instead of a regular polygon.\n * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's points facing up.\n * @property {Array<number>} [displacement=[0, 0]] Displacement of the shape in pixels.\n * Positive values will shift the shape right and up.\n * @property {import(\"./Stroke.js\").default} [stroke] Stroke style.\n * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).\n * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.\n * @property {number|import(\"../size.js\").Size} [scale=1] Scale. Unless two dimensional scaling is required a better\n * result may be obtained with appropriate settings for `radius` and `radius2`.\n * @property {import('./Style.js').DeclutterMode} [declutterMode] Declutter mode.\n */\n\n/**\n * @typedef {Object} RenderOptions\n * @property {import(\"../colorlike.js\").ColorLike|undefined} strokeStyle StrokeStyle.\n * @property {number} strokeWidth StrokeWidth.\n * @property {number} size Size.\n * @property {CanvasLineCap} lineCap LineCap.\n * @property {Array<number>|null} lineDash LineDash.\n * @property {number} lineDashOffset LineDashOffset.\n * @property {CanvasLineJoin} lineJoin LineJoin.\n * @property {number} miterLimit MiterLimit.\n */\n\n/**\n * @classdesc\n * Set regular shape style for vector features. The resulting shape will be\n * a regular polygon when `radius` is provided, or a star when both `radius` and\n * `radius2` are provided.\n * @api\n */\nclass RegularShape extends ImageStyle {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    super({\n      opacity: 1,\n      rotateWithView:\n        options.rotateWithView !== undefined ? options.rotateWithView : false,\n      rotation: options.rotation !== undefined ? options.rotation : 0,\n      scale: options.scale !== undefined ? options.scale : 1,\n      displacement:\n        options.displacement !== undefined ? options.displacement : [0, 0],\n      declutterMode: options.declutterMode,\n    });\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement|null}\n     */\n    this.hitDetectionCanvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Fill.js\").default|null}\n     */\n    this.fill_ = options.fill !== undefined ? options.fill : null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.origin_ = [0, 0];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.points_ = options.points;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.radius = options.radius;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.radius2_ = options.radius2;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.angle_ = options.angle !== undefined ? options.angle : 0;\n\n    /**\n     * @private\n     * @type {import(\"./Stroke.js\").default|null}\n     */\n    this.stroke_ = options.stroke !== undefined ? options.stroke : null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.size_;\n\n    /**\n     * @private\n     * @type {RenderOptions}\n     */\n    this.renderOptions_;\n\n    /**\n     * @private\n     */\n    this.imageState_ =\n      this.fill_ && this.fill_.loading()\n        ? ImageState.LOADING\n        : ImageState.LOADED;\n    if (this.imageState_ === ImageState.LOADING) {\n      this.ready().then(() => (this.imageState_ = ImageState.LOADED));\n    }\n    this.render();\n  }\n\n  /**\n   * Clones the style.\n   * @return {RegularShape} The cloned style.\n   * @api\n   * @override\n   */\n  clone() {\n    const scale = this.getScale();\n    const style = new RegularShape({\n      fill: this.getFill() ? this.getFill().clone() : undefined,\n      points: this.getPoints(),\n      radius: this.getRadius(),\n      radius2: this.getRadius2(),\n      angle: this.getAngle(),\n      stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n      rotation: this.getRotation(),\n      rotateWithView: this.getRotateWithView(),\n      scale: Array.isArray(scale) ? scale.slice() : scale,\n      displacement: this.getDisplacement().slice(),\n      declutterMode: this.getDeclutterMode(),\n    });\n    style.setOpacity(this.getOpacity());\n    return style;\n  }\n\n  /**\n   * Get the anchor point in pixels. The anchor determines the center point for the\n   * symbolizer.\n   * @return {Array<number>} Anchor.\n   * @api\n   * @override\n   */\n  getAnchor() {\n    const size = this.size_;\n    const displacement = this.getDisplacement();\n    const scale = this.getScaleArray();\n    // anchor is scaled by renderer but displacement should not be scaled\n    // so divide by scale here\n    return [\n      size[0] / 2 - displacement[0] / scale[0],\n      size[1] / 2 + displacement[1] / scale[1],\n    ];\n  }\n\n  /**\n   * Get the angle used in generating the shape.\n   * @return {number} Shape's rotation in radians.\n   * @api\n   */\n  getAngle() {\n    return this.angle_;\n  }\n\n  /**\n   * Get the fill style for the shape.\n   * @return {import(\"./Fill.js\").default|null} Fill style.\n   * @api\n   */\n  getFill() {\n    return this.fill_;\n  }\n\n  /**\n   * Set the fill style.\n   * @param {import(\"./Fill.js\").default|null} fill Fill style.\n   * @api\n   */\n  setFill(fill) {\n    this.fill_ = fill;\n    this.render();\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image element.\n   * @override\n   */\n  getHitDetectionImage() {\n    if (!this.hitDetectionCanvas_) {\n      this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(\n        this.renderOptions_,\n      );\n    }\n    return this.hitDetectionCanvas_;\n  }\n\n  /**\n   * Get the image icon.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {HTMLCanvasElement} Image or Canvas element.\n   * @api\n   * @override\n   */\n  getImage(pixelRatio) {\n    const fillKey = this.fill_?.getKey();\n    const cacheKey =\n      `${pixelRatio},${this.angle_},${this.radius},${this.radius2_},${this.points_},${fillKey}` +\n      Object.values(this.renderOptions_).join(',');\n    let image = /** @type {HTMLCanvasElement} */ (\n      iconImageCache.get(cacheKey, null, null)?.getImage(1)\n    );\n    if (!image) {\n      const renderOptions = this.renderOptions_;\n      const size = Math.ceil(renderOptions.size * pixelRatio);\n      const context = createCanvasContext2D(size, size);\n      this.draw_(renderOptions, context, pixelRatio);\n\n      image = context.canvas;\n      iconImageCache.set(\n        cacheKey,\n        null,\n        null,\n        new IconImage(image, undefined, null, ImageState.LOADED, null),\n      );\n    }\n    return image;\n  }\n\n  /**\n   * Get the image pixel ratio.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Pixel ratio.\n   * @override\n   */\n  getPixelRatio(pixelRatio) {\n    return pixelRatio;\n  }\n\n  /**\n   * @return {import(\"../size.js\").Size} Image size.\n   * @override\n   */\n  getImageSize() {\n    return this.size_;\n  }\n\n  /**\n   * @return {import(\"../ImageState.js\").default} Image state.\n   * @override\n   */\n  getImageState() {\n    return this.imageState_;\n  }\n\n  /**\n   * Get the origin of the symbolizer.\n   * @return {Array<number>} Origin.\n   * @api\n   * @override\n   */\n  getOrigin() {\n    return this.origin_;\n  }\n\n  /**\n   * Get the number of points for generating the shape.\n   * @return {number} Number of points for stars and regular polygons.\n   * @api\n   */\n  getPoints() {\n    return this.points_;\n  }\n\n  /**\n   * Get the (primary) radius for the shape.\n   * @return {number} Radius.\n   * @api\n   */\n  getRadius() {\n    return this.radius;\n  }\n\n  /**\n   * Get the secondary radius for the shape.\n   * @return {number|undefined} Radius2.\n   * @api\n   */\n  getRadius2() {\n    return this.radius2_;\n  }\n\n  /**\n   * Get the size of the symbolizer (in pixels).\n   * @return {import(\"../size.js\").Size} Size.\n   * @api\n   * @override\n   */\n  getSize() {\n    return this.size_;\n  }\n\n  /**\n   * Get the stroke style for the shape.\n   * @return {import(\"./Stroke.js\").default|null} Stroke style.\n   * @api\n   */\n  getStroke() {\n    return this.stroke_;\n  }\n\n  /**\n   * Set the stroke style.\n   * @param {import(\"./Stroke.js\").default|null} stroke Stroke style.\n   * @api\n   */\n  setStroke(stroke) {\n    this.stroke_ = stroke;\n    this.render();\n  }\n\n  /**\n   * @param {function(import(\"../events/Event.js\").default): void} listener Listener function.\n   * @override\n   */\n  listenImageChange(listener) {}\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {}\n\n  /**\n   * @param {function(import(\"../events/Event.js\").default): void} listener Listener function.\n   * @override\n   */\n  unlistenImageChange(listener) {}\n\n  /**\n   * Calculate additional canvas size needed for the miter.\n   * @param {string} lineJoin Line join\n   * @param {number} strokeWidth Stroke width\n   * @param {number} miterLimit Miter limit\n   * @return {number} Additional canvas size needed\n   * @private\n   */\n  calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {\n    if (\n      strokeWidth === 0 ||\n      this.points_ === Infinity ||\n      (lineJoin !== 'bevel' && lineJoin !== 'miter')\n    ) {\n      return strokeWidth;\n    }\n    // m  | ^\n    // i  | |\\                  .\n    // t >|  #\\\n    // e  | |\\ \\              .\n    // r      \\s\\\n    //      |  \\t\\          .                 .\n    //          \\r\\                      .   .\n    //      |    \\o\\      .          .  . . .\n    //          e \\k\\            .  .    . .\n    //      |      \\e\\  .    .  .       . .\n    //       d      \\ \\  .  .          . .\n    //      | _ _a_ _\\#  .            . .\n    //   r1          / `             . .\n    //      |                       . .\n    //       b     /               . .\n    //      |                     . .\n    //           / r2            . .\n    //      |                        .   .\n    //         /                           .   .\n    //      |α                                   .   .\n    //       /                                         .   .\n    //      ° center\n    let r1 = this.radius;\n    let r2 = this.radius2_ === undefined ? r1 : this.radius2_;\n    if (r1 < r2) {\n      const tmp = r1;\n      r1 = r2;\n      r2 = tmp;\n    }\n    const points =\n      this.radius2_ === undefined ? this.points_ : this.points_ * 2;\n    const alpha = (2 * Math.PI) / points;\n    const a = r2 * Math.sin(alpha);\n    const b = Math.sqrt(r2 * r2 - a * a);\n    const d = r1 - b;\n    const e = Math.sqrt(a * a + d * d);\n    const miterRatio = e / a;\n    if (lineJoin === 'miter' && miterRatio <= miterLimit) {\n      return miterRatio * strokeWidth;\n    }\n    // Calculate the distance from center to the stroke corner where\n    // it was cut short because of the miter limit.\n    //              l\n    //        ----+---- <= distance from center to here is maxr\n    //       /####|k ##\\\n    //      /#####^#####\\\n    //     /#### /+\\# s #\\\n    //    /### h/+++\\# t #\\\n    //   /### t/+++++\\# r #\\\n    //  /### a/+++++++\\# o #\\\n    // /### p/++ fill +\\# k #\\\n    ///#### /+++++^+++++\\# e #\\\n    //#####/+++++/+\\+++++\\#####\\\n    const k = strokeWidth / 2 / miterRatio;\n    const l = (strokeWidth / 2) * (d / e);\n    const maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);\n    const bevelAdd = maxr - r1;\n    if (this.radius2_ === undefined || lineJoin === 'bevel') {\n      return bevelAdd * 2;\n    }\n    // If outer miter is over the miter limit the inner miter may reach through the\n    // center and be longer than the bevel, same calculation as above but swap r1 / r2.\n    const aa = r1 * Math.sin(alpha);\n    const bb = Math.sqrt(r1 * r1 - aa * aa);\n    const dd = r2 - bb;\n    const ee = Math.sqrt(aa * aa + dd * dd);\n    const innerMiterRatio = ee / aa;\n    if (innerMiterRatio <= miterLimit) {\n      const innerLength = (innerMiterRatio * strokeWidth) / 2 - r2 - r1;\n      return 2 * Math.max(bevelAdd, innerLength);\n    }\n    return bevelAdd * 2;\n  }\n\n  /**\n   * @return {RenderOptions}  The render options\n   * @protected\n   */\n  createRenderOptions() {\n    let lineCap = defaultLineCap;\n    let lineJoin = defaultLineJoin;\n    let miterLimit = 0;\n    let lineDash = null;\n    let lineDashOffset = 0;\n    let strokeStyle;\n    let strokeWidth = 0;\n\n    if (this.stroke_) {\n      strokeStyle = asColorLike(this.stroke_.getColor() ?? defaultStrokeStyle);\n      strokeWidth = this.stroke_.getWidth() ?? defaultLineWidth;\n      lineDash = this.stroke_.getLineDash();\n      lineDashOffset = this.stroke_.getLineDashOffset() ?? 0;\n      lineJoin = this.stroke_.getLineJoin() ?? defaultLineJoin;\n      lineCap = this.stroke_.getLineCap() ?? defaultLineCap;\n      miterLimit = this.stroke_.getMiterLimit() ?? defaultMiterLimit;\n    }\n\n    const add = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);\n    const maxRadius = Math.max(this.radius, this.radius2_ || 0);\n    const size = Math.ceil(2 * maxRadius + add);\n\n    return {\n      strokeStyle: strokeStyle,\n      strokeWidth: strokeWidth,\n      size: size,\n      lineCap: lineCap,\n      lineDash: lineDash,\n      lineDashOffset: lineDashOffset,\n      lineJoin: lineJoin,\n      miterLimit: miterLimit,\n    };\n  }\n\n  /**\n   * @protected\n   */\n  render() {\n    this.renderOptions_ = this.createRenderOptions();\n    const size = this.renderOptions_.size;\n    this.hitDetectionCanvas_ = null;\n    this.size_ = [size, size];\n  }\n\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   * @param {CanvasRenderingContext2D} context The rendering context.\n   * @param {number} pixelRatio The pixel ratio.\n   */\n  draw_(renderOptions, context, pixelRatio) {\n    context.scale(pixelRatio, pixelRatio);\n    // set origin to canvas center\n    context.translate(renderOptions.size / 2, renderOptions.size / 2);\n\n    this.createPath_(context);\n\n    if (this.fill_) {\n      let color = this.fill_.getColor();\n      if (color === null) {\n        color = defaultFillStyle;\n      }\n      context.fillStyle = asColorLike(color);\n      context.fill();\n    }\n    if (renderOptions.strokeStyle) {\n      context.strokeStyle = renderOptions.strokeStyle;\n      context.lineWidth = renderOptions.strokeWidth;\n      if (renderOptions.lineDash) {\n        context.setLineDash(renderOptions.lineDash);\n        context.lineDashOffset = renderOptions.lineDashOffset;\n      }\n      context.lineCap = renderOptions.lineCap;\n      context.lineJoin = renderOptions.lineJoin;\n      context.miterLimit = renderOptions.miterLimit;\n      context.stroke();\n    }\n  }\n\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   * @return {HTMLCanvasElement} Canvas containing the icon\n   */\n  createHitDetectionCanvas_(renderOptions) {\n    let context;\n    if (this.fill_) {\n      let color = this.fill_.getColor();\n\n      // determine if fill is transparent (or pattern or gradient)\n      let opacity = 0;\n      if (typeof color === 'string') {\n        color = asArray(color);\n      }\n      if (color === null) {\n        opacity = 1;\n      } else if (Array.isArray(color)) {\n        opacity = color.length === 4 ? color[3] : 1;\n      }\n      if (opacity === 0) {\n        // if a transparent fill style is set, create an extra hit-detection image\n        // with a default fill style\n        context = createCanvasContext2D(renderOptions.size, renderOptions.size);\n        this.drawHitDetectionCanvas_(renderOptions, context);\n      }\n    }\n    return context ? context.canvas : this.getImage(1);\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context The context to draw in.\n   */\n  createPath_(context) {\n    let points = this.points_;\n    const radius = this.radius;\n    if (points === Infinity) {\n      context.arc(0, 0, radius, 0, 2 * Math.PI);\n    } else {\n      const radius2 = this.radius2_ === undefined ? radius : this.radius2_;\n      if (this.radius2_ !== undefined) {\n        points *= 2;\n      }\n      const startAngle = this.angle_ - Math.PI / 2;\n      const step = (2 * Math.PI) / points;\n      for (let i = 0; i < points; i++) {\n        const angle0 = startAngle + i * step;\n        const radiusC = i % 2 === 0 ? radius : radius2;\n        context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));\n      }\n      context.closePath();\n    }\n  }\n\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   * @param {CanvasRenderingContext2D} context The context.\n   */\n  drawHitDetectionCanvas_(renderOptions, context) {\n    // set origin to canvas center\n    context.translate(renderOptions.size / 2, renderOptions.size / 2);\n\n    this.createPath_(context);\n\n    context.fillStyle = defaultFillStyle;\n    context.fill();\n    if (renderOptions.strokeStyle) {\n      context.strokeStyle = renderOptions.strokeStyle;\n      context.lineWidth = renderOptions.strokeWidth;\n      if (renderOptions.lineDash) {\n        context.setLineDash(renderOptions.lineDash);\n        context.lineDashOffset = renderOptions.lineDashOffset;\n      }\n      context.lineJoin = renderOptions.lineJoin;\n      context.miterLimit = renderOptions.miterLimit;\n      context.stroke();\n    }\n  }\n\n  /**\n   * @override\n   */\n  ready() {\n    return this.fill_ ? this.fill_.ready() : Promise.resolve();\n  }\n}\n\nexport default RegularShape;\n"],"mappings":"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IACH;IACA,OAAOoC,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;AACA;EACES,aAAaA,CAAChB,UAAU,EAAE;IACxB,OAAOA,UAAU;EACnB;;EAEA;AACF;AACA;AACA;EACEiB,YAAYA,CAAA,EAAG;IACb,OAAO,IAAI,CAACnD,KAAK;EACnB;;EAEA;AACF;AACA;AACA;EACEoD,aAAaA,CAAA,EAAG;IACd,OAAO,IAAI,CAAClD,WAAW;EACzB;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEmD,SAASA,CAAA,EAAG;IACV,OAAO,IAAI,CAAC/D,OAAO;EACrB;;EAEA;AACF;AACA;AACA;AACA;EACEuB,SAASA,CAAA,EAAG;IACV,OAAO,IAAI,CAACtB,OAAO;EACrB;;EAEA;AACF;AACA;AACA;AACA;EACEuB,SAASA,CAAA,EAAG;IACV,OAAO,IAAI,CAACrB,MAAM;EACpB;;EAEA;AACF;AACA;AACA;AACA;EACEsB,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI,CAACrB,QAAQ;EACtB;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE4D,OAAOA,CAAA,EAAG;IACR,OAAO,IAAI,CAACtD,KAAK;EACnB;;EAEA;AACF;AACA;AACA;AACA;EACEiB,SAASA,CAAA,EAAG;IACV,OAAO,IAAI,CAACnB,OAAO;EACrB;;EAEA;AACF;AACA;AACA;AACA;EACEyD,SAASA,CAACxD,MAAM,EAAE;IAChB,IAAI,CAACD,OAAO,GAAGC,MAAM;IACrB,IAAI,CAACS,MAAM,CAAC,CAAC;EACf;;EAEA;AACF;AACA;AACA;EACEgD,iBAAiBA,CAACC,QAAQ,EAAE,CAAC;;EAE7B;AACF;AACA;AACA;EACEC,IAAIA,CAAA,EAAG,CAAC;;EAER;AACF;AACA;AACA;EACEC,mBAAmBA,CAACF,QAAQ,EAAE,CAAC;;EAE/B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEG,sBAAsBA,CAACC,QAAQ,EAAEC,WAAW,EAAEC,UAAU,EAAE;IACxD,IACED,WAAW,KAAK,CAAC,IACjB,IAAI,CAACvE,OAAO,KA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}